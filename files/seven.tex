%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%     Chapter 7
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Conclusion}
\label{seven}

In this thesis, LLVM as a new back end is introduced to the Parabix technology and a target-independent IR library of critical Parabix operations has been developed. Introducing LLVM brings in mature inter-procedure optimization and just-in-time compilers and outsources the machine-level code generation from the Parabix framework.

A systematic support for the vector of $i2^k$ has also been developed to extend the LLVM code generator with the IDISA model and a new LLVM intrinsic is added to enable chained additions on unbounded bit streams, which can be used for a broad category of applications. In one specific target: Intel X86, efficient native code has been generated and the performance is as good as the well-tuned IDISA library. In some micro-benchmarks, it even achieves 300 times speedup over the unmodified LLVM\@. Performance improvement over different sub-targets (e.g.\ X86 SSE2 and AVX2) has been witnessed without any change in the IR library.

With the LLVM back end, new optimization passes for the Parabix can be developed. As one of the major reasons for its high performance, Parabix uses long sequence of bitwise logic and shift operations without any branch or loop statement. Specific optimization like new register allocation algorithm may benefit this style of programming much more than the general programs. A peephole optimizer may be added to LLVM to combine a sequence of operations into one compact SIMD intrinsic available on the particular target.

Parabix with LLVM has better chances to target at different platforms efficiently such as the SPARC servers from the Sun and the ARM mobile platform. Further extension of the LLVM code generator can be done in the future for these platforms.

